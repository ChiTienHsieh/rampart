#!/usr/bin/env bash
#
# rampart - Run Claude Code in isolated container
#
# Usage:
#   rampart "your prompt here"
#   rampart --uv "create a FastAPI server"
#   rampart -w /path/to/project "refactor this"
#
# Flags:
#   --uv          Include Python (uv) environment
#   --npm         Include Node.js (npm) environment [TODO]
#   --playwright  Include Playwright for browser automation [TODO]
#   -w, --workspace PATH  Specify workspace directory (default: current dir)
#   --build       Force rebuild images before running
#   --shell       Open interactive shell instead of running claude
#   --ralph       Enable Ralph loop mode (iterative execution)
#   --max-iterations N    Max iterations for ralph mode (default: 10)
#   --completion-promise TEXT  Promise phrase to signal completion
#   --env KEY=VALUE  Pass environment variable to container (can be repeated)
#   -y, --yes     Skip confirmation prompts (auto-accept token)
#   -h, --help    Show this help message

set -e

# ============ Config ============

# Resolve symlinks to get the actual script location (works on vanilla macOS)
resolve_symlink() {
    local path="$1"
    while [ -L "$path" ]; do
        local dir="$(dirname "$path")"
        path="$(readlink "$path")"
        # Handle relative symlinks
        [[ "$path" != /* ]] && path="$dir/$path"
    done
    echo "$path"
}

SCRIPT_PATH="$(resolve_symlink "${BASH_SOURCE[0]}")"
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
RAMPART_DIR="$(dirname "$SCRIPT_DIR")"
COMPOSE_DIR="$RAMPART_DIR/compose"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# ============ Helpers ============

log_info() { echo -e "${BLUE}[rampart]${NC} $1" >&2; }
log_warn() { echo -e "${YELLOW}[rampart]${NC} $1" >&2; }
log_error() { echo -e "${RED}[rampart]${NC} $1" >&2; }
log_success() { echo -e "${GREEN}[rampart]${NC} $1" >&2; }

truncate_prompt() {
    local prompt="$1"
    local max_len="${2:-50}"
    if [ ${#prompt} -gt $max_len ]; then
        echo "${prompt:0:$max_len}... [truncated, see log file]"
    else
        echo "$prompt"
    fi
}

mask_token() {
    local token="$1"
    local len=${#token}
    if [ $len -le 12 ]; then
        echo "${token:0:4}****"
    else
        echo "${token:0:8}...${token: -4}"
    fi
}

show_help() {
    cat << 'EOF'
rampart - Run Claude Code in isolated container

Usage:
  rampart [flags] "your prompt"

Flags:
  --uv                    Include Python (uv) environment
  --npm                   Include Node.js (npm) environment [TODO]
  --playwright            Include Playwright [TODO]
  -w, --workspace         Workspace directory (default: current dir)
  --build                 Force rebuild images
  --shell                 Open interactive shell (no prompt needed)
  --env KEY=VALUE         Pass env var to container (repeatable)
  -y, --yes               Skip confirmation prompts
  -h, --help              Show this help

Ralph Mode (iterative execution):
  --ralph                 Enable Ralph loop mode
  --max-iterations N      Max iterations (default: 10)
  --completion-promise T  Promise phrase to signal completion

Debug:
  -v, --verbose           Show debug output (container cmd, timing)

Examples:
  rampart "fix all TypeScript errors"
  rampart --uv "create a FastAPI server with SQLAlchemy"
  rampart -w ~/projects/myapp "refactor the auth module"
  rampart --shell                    # Debug: open shell in container
  rampart --env DEBUG=1 "run tests"  # Pass env vars

  # Ralph mode - iterative execution
  rampart --ralph "fix all type errors" --completion-promise "ALL ERRORS FIXED"
  rampart --ralph --max-iterations 20 "improve test coverage to 80%"

Security:
  - Token passed via env var (not persisted in container)
  - .git is mounted read-only (always recoverable)
  - Container can access internet
  - Token can be revoked at claude.ai/settings if compromised
EOF
}

# ============ Parse Args ============

PROFILES=()
WORKSPACE="$(pwd)"
BUILD_FLAG=""
PROMPT=""
SHELL_MODE=false
RALPH_MODE=false
MAX_ITERATIONS=10
COMPLETION_PROMISE=""
VERBOSE=false
EXTRA_ENV_VARS=()
AUTO_YES=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --uv)
            PROFILES+=("uv")
            shift
            ;;
        --npm)
            PROFILES+=("npm")
            shift
            ;;
        --playwright)
            PROFILES+=("playwright")
            shift
            ;;
        -w|--workspace)
            WORKSPACE="$2"
            shift 2
            ;;
        --build)
            BUILD_FLAG="--build"
            shift
            ;;
        --shell)
            SHELL_MODE=true
            shift
            ;;
        --ralph)
            RALPH_MODE=true
            shift
            ;;
        --max-iterations)
            MAX_ITERATIONS="$2"
            shift 2
            ;;
        --completion-promise)
            COMPLETION_PROMISE="$2"
            shift 2
            ;;
        --env)
            EXTRA_ENV_VARS+=("$2")
            shift 2
            ;;
        -y|--yes)
            AUTO_YES=true
            shift
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        -*)
            log_error "Unknown flag: $1"
            show_help
            exit 1
            ;;
        *)
            # Remaining args are the prompt
            PROMPT="$*"
            break
            ;;
    esac
done

# ============ Token Auto-Detection ============

detect_token() {
    # Priority: CLAUDE_CODE_OAUTH_TOKEN > ANTHROPIC_API_KEY
    if [ -n "$CLAUDE_CODE_OAUTH_TOKEN" ]; then
        echo "CLAUDE_CODE_OAUTH_TOKEN"
        return 0
    elif [ -n "$ANTHROPIC_API_KEY" ]; then
        echo "ANTHROPIC_API_KEY"
        return 0
    fi
    return 1
}

TOKEN_VAR=""
TOKEN_VALUE=""

if TOKEN_VAR=$(detect_token); then
    TOKEN_VALUE="${!TOKEN_VAR}"
    MASKED_TOKEN=$(mask_token "$TOKEN_VALUE")

    if [ "$AUTO_YES" = false ]; then
        echo -e "${CYAN}[rampart]${NC} Detected token: ${YELLOW}$TOKEN_VAR${NC}" >&2
        echo -e "${CYAN}[rampart]${NC} Token value: ${YELLOW}$MASKED_TOKEN${NC}" >&2
        echo "" >&2
        read -p "Use this token? [Y/n] " -n 1 -r REPLY >&2
        echo "" >&2

        if [[ $REPLY =~ ^[Nn]$ ]]; then
            log_error "Token rejected by user"
            exit 1
        fi
    else
        log_info "Using token: $TOKEN_VAR ($MASKED_TOKEN)"
    fi
else
    log_error "No authentication token found"
    echo "" >&2
    echo "Please set one of the following environment variables:" >&2
    echo "  export CLAUDE_CODE_OAUTH_TOKEN='your-oauth-token'" >&2
    echo "  export ANTHROPIC_API_KEY='your-api-key'" >&2
    echo "" >&2
    echo "OAuth token: Get with 'claude auth login'" >&2
    echo "API key: Get from console.anthropic.com" >&2
    exit 1
fi

# ============ Validation ============

if [ -z "$PROMPT" ] && [ "$SHELL_MODE" = false ]; then
    log_error "No prompt provided"
    show_help
    exit 1
fi

if [ ! -d "$WORKSPACE" ]; then
    log_error "Workspace directory not found: $WORKSPACE"
    exit 1
fi

# Convert to absolute path
WORKSPACE="$(cd "$WORKSPACE" && pwd)"

# Check for .git (required for recovery)
if [ ! -d "$WORKSPACE/.git" ]; then
    log_error "No .git directory found"
    echo "" >&2
    echo "Rampart requires git for recovery. Initialize with:" >&2
    echo "  cd $WORKSPACE" >&2
    echo "  git init && git add -A && git commit -m 'init before rampart'" >&2
    exit 1
fi

# Check docker
if ! command -v docker &> /dev/null; then
    log_error "docker not found"
    exit 1
fi

if ! docker info &> /dev/null; then
    log_error "Docker daemon not running (is OrbStack running?)"
    exit 1
fi

# ============ Setup Logging ============

# Create logs directory
mkdir -p "$WORKSPACE/logs"

# Ensure logs/ is in .gitignore
GITIGNORE="$WORKSPACE/.gitignore"
if [ ! -f "$GITIGNORE" ] || ! grep -q "^logs/$" "$GITIGNORE"; then
    echo "logs/" >> "$GITIGNORE"
fi

# Create log file with timestamp
TIMESTAMP="$(date +%Y%m%d-%H%M%S)"
LOG_FILE="$WORKSPACE/logs/rampart-$TIMESTAMP.log"

# Determine mode string
if [ "$SHELL_MODE" = true ]; then
    MODE_STR="shell"
elif [ "$RALPH_MODE" = true ]; then
    MODE_STR="ralph (max: $MAX_ITERATIONS)"
else
    MODE_STR="single"
fi

# Write detailed info to log file
{
    echo "========================================"
    echo "rampart session: $TIMESTAMP"
    echo "========================================"
    echo ""
    echo "Workspace: $WORKSPACE"
    echo "Service: ${PROFILES[*]:-base}"
    echo "Mode: $MODE_STR"
    echo "Token source: $TOKEN_VAR"
    if [ "$RALPH_MODE" = true ]; then
        echo "Max iterations: $MAX_ITERATIONS"
        echo "Completion promise: ${COMPLETION_PROMISE:-none}"
    fi
    if [ ${#EXTRA_ENV_VARS[@]} -gt 0 ]; then
        echo "Extra env vars: ${EXTRA_ENV_VARS[*]}"
    fi
    echo "Started: $(date)"
    if [ "$SHELL_MODE" = false ]; then
        echo ""
        echo "Full prompt:"
        echo "----------------------------------------"
        echo "$PROMPT"
        echo "----------------------------------------"
    fi
    echo ""
} > "$LOG_FILE"

# ============ Build Profile Args ============

PROFILE_ARGS=""
SERVICE="base"

for profile in "${PROFILES[@]}"; do
    PROFILE_ARGS="$PROFILE_ARGS --profile $profile"
    SERVICE="$profile"  # Use the last profile as service name
done

# ============ Run Container ============

log_info "Workspace: $WORKSPACE"
log_info "Service: $SERVICE"
if [ "$SHELL_MODE" = true ]; then
    log_info "Mode: interactive shell"
elif [ "$RALPH_MODE" = true ]; then
    log_info "Mode: ralph loop"
    log_info "Max iterations: $MAX_ITERATIONS"
    if [ -n "$COMPLETION_PROMISE" ]; then
        log_info "Completion promise: $COMPLETION_PROMISE"
    fi
else
    log_info "Prompt: $(truncate_prompt "$PROMPT")"
fi
log_info "Log: $LOG_FILE"
echo "" >&2

if [ "$SHELL_MODE" = false ]; then
    if [ "$RALPH_MODE" = true ]; then
        echo "================================================================" >&2
        echo -e "${RED}  RAMPART MODE: Iterative autonomous execution${NC}" >&2
        echo -e "${YELLOW}  Max iterations: $MAX_ITERATIONS${NC}" >&2
        echo -e "${GREEN}  Recovery: git checkout . && git clean -fd${NC}" >&2
        echo "================================================================" >&2
    else
        echo "================================================================" >&2
        echo -e "${RED}  RAMPART MODE: Claude will execute autonomously${NC}" >&2
        echo -e "${GREEN}  Recovery: git checkout . && git clean -fd${NC}" >&2
        echo "================================================================" >&2
    fi
    echo "" >&2
fi

cd "$COMPOSE_DIR"

# Export for docker-compose
export WORKSPACE

# Set token env vars based on what was detected
if [ "$TOKEN_VAR" = "CLAUDE_CODE_OAUTH_TOKEN" ]; then
    export CLAUDE_CODE_OAUTH_TOKEN="$TOKEN_VALUE"
    export ANTHROPIC_API_KEY=""
else
    export ANTHROPIC_API_KEY="$TOKEN_VALUE"
    export CLAUDE_CODE_OAUTH_TOKEN=""
fi

# Build if needed
if [ -n "$BUILD_FLAG" ]; then
    log_info "Building images..."
    docker compose $PROFILE_ARGS build
fi

# Build extra env args for docker compose
EXTRA_ENV_ARGS=""
for env_var in "${EXTRA_ENV_VARS[@]}"; do
    EXTRA_ENV_ARGS="$EXTRA_ENV_ARGS -e $env_var"
done

# Determine container command
if [ "$SHELL_MODE" = true ]; then
    CONTAINER_CMD="bash"
elif [ "$RALPH_MODE" = true ]; then
    # Generate ralph loop script to run inside container
    # Write script to temp file to avoid multiline bash -c issues
    RALPH_SCRIPT_FILE="/tmp/claude/ralph-script-$$.sh"
    mkdir -p /tmp/claude

    cat > "$RALPH_SCRIPT_FILE" << 'RALPH_EOF'
#!/bin/bash
set -e

MAX_ITER="$1"
PROMISE="$2"
shift 2
PROMPT="$*"

# Add promise instruction if set
if [ -n "$PROMISE" ]; then
    FULL_PROMPT="$PROMPT

To signal completion, you MUST output exactly: [[PROMISE: $PROMISE]]
ONLY output this when the statement is completely TRUE. Do NOT lie to exit."
else
    FULL_PROMPT="$PROMPT"
fi

echo "ðŸ”„ Ralph loop starting (max: $MAX_ITER iterations)" >&2
echo "" >&2

for i in $(seq 1 $MAX_ITER); do
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" >&2
    echo "ðŸ”„ Ralph iteration $i/$MAX_ITER" >&2
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" >&2

    # Create temp file to capture output while still displaying it
    TEMP_OUTPUT="/tmp/ralph-output-$$"

    if [ $i -eq 1 ]; then
        # First iteration: use -p flag
        claude -p "$FULL_PROMPT" --dangerously-skip-permissions --output-format text 2>&1 | tee "$TEMP_OUTPUT"
    else
        # Subsequent iterations: use --continue with stdin
        echo "$FULL_PROMPT" | claude --continue --dangerously-skip-permissions --output-format text 2>&1 | tee "$TEMP_OUTPUT"
    fi

    # Check for completion promise
    if [ -n "$PROMISE" ]; then
        if grep -qF "[[PROMISE: $PROMISE]]" "$TEMP_OUTPUT" 2>/dev/null; then
            echo "" >&2
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" >&2
            echo "âœ… Completion promise detected!" >&2
            echo "   [[PROMISE: $PROMISE]]" >&2
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" >&2
            rm -f "$TEMP_OUTPUT"
            exit 0
        fi
    fi

    rm -f "$TEMP_OUTPUT"

    if [ $i -lt $MAX_ITER ]; then
        echo "" >&2
        echo "â³ No promise detected, continuing..." >&2
        echo "" >&2
    fi
done

echo "" >&2
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" >&2
echo "ðŸ›‘ Max iterations ($MAX_ITER) reached" >&2
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" >&2
RALPH_EOF

    chmod +x "$RALPH_SCRIPT_FILE"

    # Escape prompt for shell argument passing
    ESCAPED_PROMPT=$(printf '%s' "$PROMPT" | sed "s/'/'\\\\''/g")
    ESCAPED_PROMISE=$(printf '%s' "$COMPLETION_PROMISE" | sed "s/'/'\\\\''/g")

    CONTAINER_CMD="bash /workspace/.ralph-script.sh '$MAX_ITERATIONS' '$ESCAPED_PROMISE' '$ESCAPED_PROMPT'"

    # We'll copy the script to workspace so it's accessible inside container
    cp "$RALPH_SCRIPT_FILE" "$WORKSPACE/.ralph-script.sh"
    rm "$RALPH_SCRIPT_FILE"

    # Add cleanup trap to remove script after run
    trap 'rm -f "$WORKSPACE/.ralph-script.sh" 2>/dev/null' EXIT
else
    CONTAINER_CMD="claude -p \"$PROMPT\" --dangerously-skip-permissions --output-format text"
fi

# Verbose debug output
if [ "$VERBOSE" = true ]; then
    echo "" >&2
    echo -e "${YELLOW}[verbose]${NC} â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" >&2
    echo -e "${YELLOW}[verbose]${NC} Docker compose dir: $COMPOSE_DIR" >&2
    echo -e "${YELLOW}[verbose]${NC} Profile args: ${PROFILE_ARGS:-none}" >&2
    echo -e "${YELLOW}[verbose]${NC} Service: $SERVICE" >&2
    echo -e "${YELLOW}[verbose]${NC} Token source: $TOKEN_VAR" >&2
    if [ "$RALPH_MODE" = true ]; then
        echo -e "${YELLOW}[verbose]${NC} Ralph mode: iterations=$MAX_ITERATIONS, promise='$COMPLETION_PROMISE'" >&2
    fi
    if [ ${#EXTRA_ENV_VARS[@]} -gt 0 ]; then
        echo -e "${YELLOW}[verbose]${NC} Extra env vars: ${EXTRA_ENV_VARS[*]}" >&2
    fi
    echo -e "${YELLOW}[verbose]${NC} Container command (truncated):" >&2
    echo -e "${YELLOW}[verbose]${NC}   $(echo "$CONTAINER_CMD" | head -c 200)..." >&2
    echo -e "${YELLOW}[verbose]${NC} â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" >&2
    echo "" >&2
fi

if [ "$SHELL_MODE" = true ]; then
    # Shell mode: use detached + attach for interactive TTY
    CONTAINER_ID=$(docker compose $PROFILE_ARGS run -d $EXTRA_ENV_ARGS "$SERVICE" bash)

    log_info "Container: ${CONTAINER_ID:0:12}"
    echo "Container ID: $CONTAINER_ID" >> "$LOG_FILE"
    echo "" >&2
    log_info "To exec: docker exec -it ${CONTAINER_ID:0:12} bash"
    echo "" >&2

    set +e
    docker attach "$CONTAINER_ID"
    set -e

    # Wait and cleanup
    docker wait "$CONTAINER_ID" > /dev/null 2>&1 || true
    EXIT_CODE=$(docker inspect "$CONTAINER_ID" --format='{{.State.ExitCode}}' 2>/dev/null || echo "0")
    docker rm "$CONTAINER_ID" > /dev/null 2>&1 || true
else
    # Prompt mode: run with output capture
    {
        echo ""
        echo "========================================"
        echo "Container output:"
        echo "========================================"
    } >> "$LOG_FILE"

    set +e
    # -T disables pseudo-TTY for better output capture
    docker compose $PROFILE_ARGS run -T --rm $EXTRA_ENV_ARGS "$SERVICE" \
        bash -c "$CONTAINER_CMD" 2>&1 | tee -a "$LOG_FILE"
    EXIT_CODE=${PIPESTATUS[0]}
    set -e
fi

# ============ Summary ============

echo "" >&2
log_info "Exit code: $EXIT_CODE"

# Log summary to file
{
    echo ""
    echo "========================================"
    echo "Session ended: $(date)"
    echo "Exit code: $EXIT_CODE"
    echo "========================================"
    echo ""
    echo "Git status:"
    cd "$WORKSPACE"
    git status --short 2>/dev/null || echo "(no changes)"
} >> "$LOG_FILE"

# Minimal stdout summary
echo "" >&2
log_info "Log: $LOG_FILE"
log_info "Recovery: git checkout . && git clean -fd"

exit $EXIT_CODE
